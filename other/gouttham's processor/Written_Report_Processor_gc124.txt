Written Report -- Gouttham Chandrasekar
ECE 350 Processor. 
03/22/2019


 Your report should cover the details of your processor design, including regfile, ALU, and
multdiv

Brief Overview of Design. What are the important modules? 
    Processor Design: My processor included 5 sections. Fetch, Decode, Execute, Memory and Writeback each of which takes 1 clock cycle to complete.
    This design allows for instructions to be pipelined allowing multiple instructions to concurrently run. To pipeline, it is important to define 
    the goal of each stage in the pipeline explicitly s.t. each instruction in the program has a place to go in the processor for each of its functions.
    I will now go over the details of each stage of my pipelined processor. A detailed design of each stage of pipeline will be in visual and presentation. 
    Each Stage is seperated into 3 parts. Logic, bypassing/stall, and latch. 
    fetch --> (logic) calculate next pc. (Bypassing/Stall) None  (latch) instr,pc
    decode --> (logic) calculate regA and regB (Bypassing/Stall) writeback or fd latch for regA and regB  (latch) fd, instr, regA, regB
    execute --> (logic) alu. branching pc calculation. rstatus exception number calculation. (bypass/stall) writeback->execute memory->execute for each register (latch) alu_output, regB, pc, instr
    memory --> (logic) store/retrieve from dmem. (bypass/stall) writeback -> memory (latch) mw instr, pc, alu_out. 
    writeback --> logic (data_writeback, ctrl_writeback). 
    



The processor design included 
● You should include details on:
○ How you implemented each instruction
    I will briefly go over each instruction in this report. 
    add/sub/and/or/sll/sra/mult/diva/addi --> the computation occurs in the alu. The decode stage defined the inputs to the alu. 
    blt/bne/j/jal/jr -->    the pc offset computation also occurs in the execute stage within the execute branch logic function. Then, the new pc is fed into the 
                            pc_next in the pc_register. That way, in the next cycle, the jumped location will be the next pc. minor Implementation details will be in presentation
    sw/lw           -->     accesses the dmem file and either loads or stores info at the memory stage. The rs is added to N in alu and rd is untouched until we reach memory stage.
    setx            -->     with the help of rstatus register and reg30, we use logic similar to jal to store the pc into a special register (30). we also take the alu_overflow to 
                            populate the rstatus register with the correct exception number. 
    bex             -->     Similar to jal logic. Throw a value into a special register in the writeback stage.
    jal             -->     store pc + 1 into a special register (31) and then jump to T in execute stage



○ Why you chose your implementation
    I chose my implementation because pipelining instructions with bypassing and stalls make reading the instructions easy to comprehend and debug. The
    design allows most sequences of MIIPS instructions to run in 20ns without any need for noops. The only instructions that require a stall are
    lw followed by another instruction that use the lw register as an input 1 instruction later. I also decided to include an extra register for rstatus
    information because if I wrote to register 30 every time my rstatus updated, I would have to wait until the rstatus value travelled to the writeback stage
    to read the information.

○ How you tested your implementation
    I included a unit test for each feature that I implemented in the project. I tried to isolate that feature in my unit test as much as possible to 
    make debugging easier. Then, after I tested each isolated feature, I had a couple instruction sets that integrated multiple implementatation features.
    This made it easy to debug my code and make sure that as I write more code, the old features I implement don't break. With every feature I added,
    I would run all of my unit tests to check the functionality of my program. 


○ The challenges you faced and how you overcame them
    I ran into many challenges when debugging my program. I relied on rechecking my code regularly before running the program and looking scrupulously for 
    warnings and errors generated by the program. In addition, with every feature I implemented, I would unit test all of my previous features. 
    Initially, I had no idea how to begin writing the verilog code and took 4 days to think about how to tackle the project. This brainstorming helped me warm
    up to the problem. 
● If your processor has errors or issues, you should include extensive details as to what
these issues are, why they occur, how you attempted to fix them, how you tested your
processor to find these issues, and how these issues can be fixed
    I think my code works for all of bypassing, stalling, regular pipelining and all of the instructions. I have tested each instruction and each feature with 
    atleast one unit test and one integration test and have attached my test suite in the gitrepo. Additionally, I ran out of time and wasn't able to implement
    multdiv stalling and integration. If I were to have time, I would add my multdiv module inside my alu module. If a mult or div instruction is requested, 
    I would call into the multdiv module and surface three important wires. 1) multdiv result and 2)multdiv_inprogress 3)multdiv_ready. If multdiv_inprogress is true, I will halt 
    all of my pipeline registers. If the multdiv isn't in progress and the multdiv_ready flag is 1, then I would read the answer and then send it into my xm_O latch. 
    With some fine tuning, this should successfully integrate mult and div into my code.