DEPTH = 4096;
WIDTH = 32;
ADDRESS_RADIX = DEC;
DATA_RADIX = BIN;
CONTENT
BEGIN
0000 : 01000000010000000000000000000000; -- 	lw $1 0($0)			# b_xpos [31:21]

0001 : 00111000010000000000000001100100; -- 	sw $1 100($0)

0002 : 01000000010000000000000000000001; -- 	lw $1 1($0)			# b_ypos [20:10]

0003 : 00111000010000000000000001100101; -- 	sw $1 101($0)

0004 : 01000000010000000000000000000010; -- 	lw $1 2($0) 		# b_xvel [9:5]

0005 : 00111000010000000000000001100110; -- 	sw $1 102($0)

0006 : 01000000010000000000000000000011; -- 	lw $1 3($0)			# b_yvel [4:0]

0007 : 00111000010000000000000001100111; -- 	sw $1 103($0)

0008 : 01000000010000000000000000110010; -- 	lw $1 50($0) 		# gametime

0009 : 00111000010000000000000010010110; -- 	sw $1 150($0)

0010 : 01000000010000000000000000110011; -- 	lw $1 51($0) 		# note pointer

0011 : 00111000010000000000000010010111; -- 	sw $1 151($0)

0012 : 01000000010000000000000000110100; -- 	lw $1 52($0) 		# note speed

0013 : 00111000010000000000000010011000; -- 	sw $1 152($0)

0014 : 00011000000000000000000001101111; -- 	jal push_to_reg10

0015 : 00000000010000000000000000000000; -- 	add $1 $0 $0

0016 : 01000000100000000000000000001000; -- 	lw $2 8($0)						

0017 : 00101000010000100000000000000001; -- 		addi $1 $1 1

0018 : 00010000010001011111111111111110; -- 		bne $1 $2 counterincrement

0019 : 01000000010000000000000010010110; -- 	lw $1 150($0)

0020 : 00101000010000100000000000000001; -- 	addi $1 $1 1

0021 : 00111000010000000000000010010110; -- 	sw $1 150($0)

0022 : 00101011111010000000000000000000; -- 	    addi $15 $20 0      # move note data to temp func reg

0023 : 00011000000000000000000010000111; -- 	    jal check_high_note # update note 1

0024 : 00011000000000000000000010001100; -- 	    jal check_low_note  # update note 2

0025 : 00101101000111100000000000000000; -- 	    addi $20 $15 0      # move updated note data back to note reg

0026 : 00101011111010100000000000000000; -- 	    addi $15 $21 0      # move note data to temp func reg

0027 : 00011000000000000000000010000111; -- 	    jal check_high_note # update note 3

0028 : 00011000000000000000000010001100; -- 	    jal check_low_note  # update note 4

0029 : 00101101010111100000000000000000; -- 	    addi $21 $15 0      # move updated note data back to note reg

0030 : 00101011111011000000000000000000; -- 	    addi $15 $22 0      # move note data to temp func reg

0031 : 00011000000000000000000010000111; -- 	    jal check_high_note # update note 5

0032 : 00011000000000000000000010001100; -- 	    jal check_low_note  # update note 6

0033 : 00101101100111100000000000000000; -- 	    addi $22 $15 0      # move updated note data back to note reg

0034 : 01000000010000000000000000001011; -- 				lw $1 11($0) 				# left_wall

0035 : 01000000100000000000000001100100; -- 				lw $2 100($0)				# ballxpos																

0036 : 00110000010001000000000001000010; -- 				blt $1 $2 hit_left_wall 	# ballxpos < left_wall

0037 : 01000000010000000000000000001100; -- 				lw $1 12($0)				# right_wall

0038 : 01000000100000000000000000000100; -- 				lw $2 4($0) 				# ball_length

0039 : 01000000110000000000000001100100; -- 				lw $3 100($0) 				# ballxpos

0040 : 00000000110001000011000000000000; -- 				add $3 $2 $3 				# ballxpos + ball_length = ball_right_boundry

0041 : 00110000110000100000000000111101; -- 				blt $3 $1 hit_right_wall	# ball_right_boundry < right_wall { hit right wall }

0042 : 01000000010000000000000001100101; -- 				lw $1 101($0) 				# t_ball

0043 : 01000000100000000000000001110100; -- 				lw $2 116($0)				# t_paddleL

0044 : 01000000110000000000000000000110; -- 				lw $3 6($0)					# paddle_length

0045 : 00000000110001000011000000000000; -- 				add $3 $2 $3 				# t_paddleL + paddle_length = b_paddleL

0046 : 00110000010001100000000000010000; -- 				blt $1 $3 end_lp_coll_check # if (top_ball > b_paddleL) { no left paddle collision }

0047 : 01000000010000000000000001100101; -- 				lw $1 101($0) 				# t_ball

0048 : 01000000100000000000000000000100; -- 				lw $2 4($0) 	 			# b_length

0049 : 00000000010000100010000000000000; -- 				add $1 $1 $2 				# b_ball = t_ball + b_length

0050 : 01000000100000000000000001110100; -- 				lw $2 116($0) 				# t_paddleL

0051 : 00110000100000100000000000001011; -- 				blt $2 $1 end_lp_coll_check # if (t_paddleL > b_ball) { no left paddle collision }

0052 : 01000000010000000000000001110011; -- 				lw $1 115($0) 				# l_paddleL

0053 : 01000000100000000000000000000101; -- 				lw $2 5($0) 	 			# paddle_width

0054 : 00000000010000100010000000000000; -- 				add $1 $1 $2 				# r_paddleL = l_paddleL + paddle_width

0055 : 01000000100000000000000001100100; -- 				lw $2 100($0) 				# l_ball

0056 : 00110000100000100000000000000110; -- 				blt $2 $1 end_lp_coll_check # l_ball > r_paddleL

0057 : 01000000010000000000000001110011; -- 				lw $1 115($0) 				# l_paddleL

0058 : 01000000100000000000000001100100; -- 				lw $2 100($0) 				# l_ball

0059 : 01000000110000000000000000000100; -- 				lw $3 4($0)					# ball_length

0060 : 00000000100001000011000000000000; -- 				add $2 $2 $3				# r_ball

0061 : 00110000010001000000000000000001; -- 				blt $1 $2 end_lp_coll_check # l_paddleL > r_ball

0062 : 00001000000000000000000001100111; -- 				j negate_x_vel

0063 : 01000000010000000000000001100101; -- 				lw $1 101($0) 				# t_ball

0064 : 01000000100000000000000001110110; -- 				lw $2 118($0)				# t_paddleR

0065 : 01000000110000000000000000000110; -- 				lw $3 6($0)					# paddle_length

0066 : 00000000110001000011000000000000; -- 				add $3 $2 $3 				# t_paddleR + paddle_length = b_paddleR

0067 : 00110000010001100000000000010000; -- 				blt $1 $3 end_rp_coll_check 		# if (top_ball > b_paddleR) { no left paddle collision }

0068 : 01000000010000000000000001100101; -- 				lw $1 101($0) 				# t_ball

0069 : 01000000100000000000000000000100; -- 				lw $2 4($0) 	 			# b_length

0070 : 00000000010000100010000000000000; -- 				add $1 $1 $2 				# b_ball = t_ball + b_length

0071 : 01000000100000000000000001110110; -- 				lw $2 118($0) 				# t_paddleR

0072 : 00110000100000100000000000001011; -- 				blt $2 $1 end_rp_coll_check # if (t_paddleR > b_ball) { no left paddle collision }

0073 : 01000000010000000000000001100100; -- 				lw $1 100($0) 				# l_ball

0074 : 01000000100000000000000000000100; -- 				lw $2 4($0) 	 			# ball_length

0075 : 00000000010000100010000000000000; -- 				add $1 $1 $2 				# r_ball = l_BALL + ball_length

0076 : 01000000100000000000000001110101; -- 				lw $2 117($0) 				# l_paddleR

0077 : 00110000100000100000000000000110; -- 				blt $2 $1 end_rp_coll_check # l_paddleR > r_BALL

0078 : 01000000010000000000000001100100; -- 				lw $1 100($0) 				# l_ball

0079 : 01000000100000000000000001110101; -- 				lw $2 117($0)				# l_paddleR

0080 : 01000000110000000000000000000101; -- 				lw $3 5($0)					# paddle_width

0081 : 00000000100001000011000000000000; -- 				add $2 $2 $3  				# r_paddleR

0082 : 00110000010001000000000000000001; -- 				blt $1 $2 end_rp_coll_check # l_ball > r_paddleR

0083 : 00001000000000000000000001100111; -- 				j negate_x_vel

0084 : 00001000000000000000000001010101; -- 				j update_bx

0085 : 01000000010000000000000001100100; -- 			lw $1 100($0) 	# $1: Ball x position.

0086 : 01000000110000000000000001100110; -- 			lw $3 102($0)	# $3: Ball x velocity

0087 : 00000001000000100011000000000000; -- 			add $4 $1 $3	# $6: newx = oldx + deltax

0088 : 00111001000000000000000001100100; -- 			sw $4 100($0)	# store newx

0089 : 01000000010000000000000000001001; -- 				lw $1 9($0)					# top_wall_pos

0090 : 01000000100000000000000001100101; -- 				lw $2 101($0) 				# ball_y_pos

0091 : 00110000010001000000000000001111; -- 				blt $1 $2 hit_top_wall		# top_wall_pos > ball_y_pos

0092 : 01000000010000000000000000001010; -- 				lw $1 10($0)				# bottom_wall_pos

0093 : 01000000100000000000000001100101; -- 				lw $2 101($0) 				# ball_y_pos

0094 : 01000000110000000000000000000100; -- 				lw $3 4($0)		 			# ball_length

0095 : 00000000110001100010000000000000; -- 				add $3 $3 $2 				# ball_ypos + ball_length = ball_bottom_boundry

0096 : 00110000110000100000000000001010; -- 				blt $3 $1 hit_bottom_wall 	# if (ball_bottom_boundry > bottom_wall_pos) { hit_bottom_wall }

0097 : 01000000010000000000000001100101; -- 			lw $1 101($0) 					# ball_oldypos

0098 : 01000000100000000000000001100111; -- 			lw $2 103($0)					# ballyvel

0099 : 00000000100001000001000000000000; -- 			add $2 $2 $1					# newy = ball_oldypos + ballyvel

0100 : 00111000100000000000000001100101; -- 			sw $2 101($0) 					# store newy into 101.

0101 : 00011000000000000000000001101111; -- 	jal push_to_reg10

0102 : 00001000000000000000000000001111; -- j bufferloop

0103 : 01000000110000000000000001100110; -- 	lw $3 102($0)	# $3: Ball x velocity

0104 : 00000001000000000011000000000100; -- 	sub $4 $0 $3 	# Negate x velocity

0105 : 00111001000000000000000001100110; -- 	sw $4 102($0)	# Store new x velocity into function. 

0106 : 00001000000000000000000001010101; -- 	j update_bx

0107 : 01000000010000000000000001100111; -- 	lw $1 103($0)	# Ball y velocity

0108 : 00000000010000000001000000000100; -- 	sub $1 $0 $1	# Negate y velocity

0109 : 00111000010000000000000001100111; -- 	sw $1 103($0) 	# Insert new ball velocity into dmem

0110 : 00001000000000000000000001100001; -- 	j update_by

0111 : 00000001100000000000000000000000; -- 	add $6 $0 $0

0112 : 01000000010000000000000001100100; -- 	lw $1 100($0)			# b_xpos [31:21]

0113 : 01000000100000000000000001100101; -- 	lw $2 101($0)			# b_ypos [20:10]

0114 : 01000000110000000000000001100110; -- 	lw $3 102($0) 			# b_xvel [9:5]

0115 : 01000001000000000000000001100111; -- 	lw $4 103($0)			# b_yvel [4:0]

0116 : 00000000010000100000101010010000; -- 	sll $1 $1 21

0117 : 00000001100011000001000000000000; -- 	add $6 $6 $1

0118 : 00101001010000000000011111111111; -- 	addi $5 $0 2047

0119 : 00000001010010100000010100010000; -- 	sll $5 $5 10

0120 : 00000000100001000000010100010000; -- 	sll $2 $2 10

0121 : 00000000100001000101000000001000; -- 	and $2 $2 $5

0122 : 00000001100011000010000000000000; -- 	add $6 $6 $2

0123 : 00101001010000000000000000011111; -- 	addi $5 $0 31

0124 : 00000001010010100000001010010000; -- 	sll $5 $5 5

0125 : 00000000110001100000001010010000; -- 	sll $3 $3 5

0126 : 00000000110001100101000000001000; -- 	and $3 $3 $5

0127 : 00000001100011000011000000000000; -- 	add $6 $6 $3

0128 : 00101001010000000000000000011111; -- 	addi $5 $0 31

0129 : 00000001010010100000000000010000; -- 	sll $5 $5 0

0130 : 00000001000010000000000000010000; -- 	sll $4 $4 0

0131 : 00000001000010000101000000001000; -- 	and $4 $4 $5

0132 : 00000001100011000100000000000000; -- 	add $6 $6 $4

0133 : 00101010100011000000000000000000; -- 	addi $10 $6 0

0134 : 00100111110000000000000000000000; -- 	jr $31

0135 : 00101100000000000000000000000111; --     addi $16 $0 7    # mask to determine if high bit note exists ([20:18] is non-zero)

0136 : 00000100001000000000100100010000; --     sll $16 $16 18    # align to relevant bits

0137 : 00000100001000001111000000001000; --     and $16 $16 $15   # isolate relevant bits

0138 : 00010100000000000000000000000101; --     bne $16 $0 note_high_notempty    # jump if note exists

0139 : 00001000000000000000000010011000; --     j note_high_empty                # else jump to make a note

0140 : 00101100000000000000000000011100; --     addi $16 $0 28      # mask to determine if low bit note exists ([4:2] is non-zero)

0141 : 00000100001000001111000000001000; --     and $16 $16 $15      # isolate relevant bits

0142 : 00010100000000000000000000000101; --     bne $16 $0 note_low_notempty    # jump if note exists

0143 : 00001000000000000000000010011101; --     j note_low_empty    # else jump to make a note

0144 : 01000100000000000000000010011000; --     lw $16 152($0)   # load note velocity into $16

0145 : 00000100001000000000101010010000; --     sll $16 $16 21  # shift velocity to be aligned with high bit note pos [31:21]

0146 : 00000011110111110000000000000000; --     add $15 $15 $16 # add velocity to high bit note pos

0147 : 00100111110000000000000000000000; --     jr $31          # note's position has been updated, return to game loop

0148 : 01000100000000000000000010011000; --     lw $16 152($0)   # load note velocity into $16

0149 : 00000100001000000000001010010000; --     sll $16 $16 5  # shift velocity to be aligned with high bit note pos [31:21]

0150 : 00000011110111110000000000000000; --     add $15 $15 $16 # add velocity to high bit note pos

0151 : 00100111110000000000000000000000; --     jr $31          # note's position has been updated, return to game loop

0152 : 01000100000000000000000010010111; --     lw $16 151($0)       # load note pointer into $16

0153 : 01000100011000000000000000000001; --     lw $17 1($16)       # load the time of the next note into $17

0154 : 01000100100000000000000010010110; --     lw $18 150($0)       # load the game loop counter into $18

0155 : 00110100101000100000000000000110; --     blt $18 $17 make_high_note # if counter is greater than next note time, make note

0156 : 00100111110000000000000000000000; --     jr $31              # else, keep note empty, return to game loop

0157 : 01000100000000000000000010010111; --     lw $16 151($0)       # load note pointer into $16

0158 : 01000100011000000000000000000001; --     lw $17 1($16)       # load the time of the next note into $17

0159 : 01000100100000000000000010010110; --     lw $18 150($0)       # load the game loop counter into $18

0160 : 00110100101000100000000000001000; --     blt $18 $17 make_low_note # if counter is greater than next note time, make note

0161 : 00100111110000000000000000000000; --     jr $31              # else, keep note empty, return to game loop

0162 : 01000100000000000000000010010111; --     lw $16 151($0)       # load note pointer into $16

0163 : 01000100011000000000000000000000; --     lw $17 0($16)       # load the value of the next note into $17

0164 : 00000100011000100000100100010000; --     sll $17 $17 18      # shift left to align note value to relevant high bits... change shamt to 16 if initializing hits too

0165 : 00000011110111110001000000001100; --     or $15 $15 $17      # insert new note value into $15 (upper bits of $15 should be 0)

0166 : 00101100001000000000000000000010; --     addi $16 $16 2       # increment note pointer to next note

0167 : 00111100000000000000000010010111; --     sw $16 151($0)       # store new note pointer into DMEM

0168 : 00100111110000000000000000000000; --     jr $31

0169 : 01000100000000000000000010010111; --     lw $16 151($0)       # load note pointer into $16

0170 : 01000100011000000000000000000000; --     lw $17 0($16)       # load the value of the next note into $17

0171 : 00000100011000100000000100010000; --     sll $17 $17 2       # shift left to align note value to relevant low bits... change shamt to 0 or delete line if initializing hits too

0172 : 00000011110111110001000000001100; --     or $15 $15 $17      # insert new note value into $15 (upper bits of $15 should be 0)

0173 : 00101100001000000000000000000010; --     addi $16 $16 2       # increment note pointer to next note

0174 : 00111100000000000000000010010111; --     sw $16 151($0)       # store new note pointer into DMEM

0175 : 00100111110000000000000000000000; --     jr $31

[0176..4095] : 00000000000000000000000000000000;
END;
